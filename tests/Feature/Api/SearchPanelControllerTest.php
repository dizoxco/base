<?php

namespace Test\Feature\Api;

use App\Models\Post;
use App\Models\SearchPanel;
use App\Models\User;
use Illuminate\Foundation\Testing\WithFaker;
use Spatie\Permission\Models\Role;
use Spatie\Permission\PermissionRegistrar;
use Symfony\Component\HttpFoundation\Response;
use Tests\TestCase;

class SearchPanelControllerTest extends TestCase
{
    use WithFaker;

    protected   $providedData   =   [];

    /**
     * @return mixed
     */
    public function userWithManageSearchPanelsPermission()
    {
        $this->artisan('db:seed', ['--class' => 'PermissionsTableSeeder']);
        $this->artisan('db:seed', ['--class' => 'RolesTableSeeder']);
        $search_panel = factory(User::class)->create()->assignRole(Role::first());

        $this->assertTrue($search_panel->hasRole('admin'));
        $this->assertTrue($search_panel->hasPermissionTo('manage_search_panels', 'api'));
        $this->assertCount(1, User::all());
        return $search_panel;
    }

    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->app->make(PermissionRegistrar::class)->forgetCachedPermissions();
        $this->app->make(PermissionRegistrar::class)->registerPermissions();
    }

    protected function login(User $user = null)
    {
        return $this->clearConfigurationCache()->installPassport()->signInFromApi($user);
    }

    protected function routeIndex()
    {
        return route('api.searchpanels.index');
    }

    protected function routeStore()
    {
        return route('api.searchpanels.store');
    }

    protected function routeShow($search_panel)
    {
        return route('api.searchpanels.show', ['search_panel'   =>  $search_panel]);
    }

    protected function routeUpdate($search_panel)
    {
        return route('api.searchpanels.update', ['search_panel' => $search_panel]);
    }

    protected function routeDelete($search_panel)
    {
        return route('api.searchpanels.delete', ['search_panel' => $search_panel]);
    }

    protected function routeRestore($search_panel)
    {
        return route('api.searchpanels.restore', ['search_panel' => $search_panel]);
    }

    protected function routeDestroy($search_panel)
    {
        return route('api.searchpanels.destroy', ['search_panel' => $search_panel]);
    }

    protected function dataProvider()
    {
        $title  =   $this->faker->sentence();
        $this->providedData =   [
            'title'         =>  $title,
            'slug'          =>  str_slug($title),
            'description'   =>  $this->faker->sentences(3, true),
            'model'         =>  Post::class,
            'options'       =>  json_encode([
                'price' =>  [
                    'label' =>  'برچسب',
                    'query' =>  'between',
                    'field' =>  'price',
                    'min'   =>  mt_rand(1,15),
                    'max'   =>  mt_rand(16,30),
                ]
            ]),
            'filters'       =>  json_encode([
                'type' =>  [
                    'label' =>  'نوع',
                    'query' =>  '=',
                    'field' =>  'type',
                    'items' =>  [
                        [
                            'label' =>  'نوع اول',
                            'value' =>  1,
                        ],
                        [
                            'label' =>  'نوع دوم',
                            'value' =>  2,
                        ],
                        [
                            'label' =>  'نوع سوم',
                            'value' =>  3,
                        ],
                    ]
                ]
            ]),
        ];
        return $this;
    }

    protected function getData()
    {
        return $this->providedData;
    }

    protected function withPutMethod()
    {
        $this->providedData['_method']  =   'put';
        return $this;
    }

    protected function without(...$without)
    {
        if (count(func_get_args()) > 0) {
            foreach ($without as $key) {
                unset($this->providedData[$key]);
            }
        }

        return $this->providedData;
    }

    /**
     * @group search.panel.index
     * @test Let's check that it can show all search panels or not
     */
    public function it_should_shows_all_available_search_panels_to_privileged_users()
    {
        factory(SearchPanel::class, 5)->create(
            $this->dataProvider()->without('title','slug','description')
        );
        $search_panel   =   $this->userWithManageSearchPanelsPermission();
        $response       =   $this->login($search_panel)->getJson($this->routeIndex());
        $response->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure([
                'data'  =>  ['*'    =>  [
                    'id','title','slug','description','model','options','filters'
                ]]
            ]);

        $panels =   $response->decodeResponseJson()['data'];
        foreach ($panels as $panel) {
            $this->assertJson($panel['options']);
            $this->assertJson($panel['filters']);
        }
    }

    /**
     * @group search.panel.index
     * @test Let's check that it can reject non auth users requests or not
     */
    public function it_should_only_auth_user_with_manage_search_panels_permission_can_access()
    {
        factory(SearchPanel::class)->create(
            $this->dataProvider()->without('title','slug','description')
        );
        $response       =   $this->getJson($this->routeIndex());
        $response->assertStatus(Response::HTTP_UNAUTHORIZED)
//            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson(enum('system.response.unauthenticated'));

        // fixme: content-type is app/json
    }

    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request without title or not
     */
    public function it_must_reject_search_panel_store_requests_without_title()
    {
        $garbage    =   'title';
        $data       =   $this->dataProvider()->without($garbage);

        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
           'slug'   =>  $data['slug'],
           'model'  =>  $data['model'],
        ]);
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with non string title or not
     */
    public function it_must_reject_search_panel_store_requests_with_non_string_title()
    {
        $garbage    =   'title';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([null, false, true, '', []] as $invalid_title) {

            $data['title']  =   $invalid_title;
            $response       =   $this->postJson($this->routeStore(), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'slug'   =>  $data['slug'],
                'model'  =>  $data['model'],
            ]);
        }
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request without slug or not
     */
    public function it_must_reject_search_panel_store_requests_without_slug()
    {
        $garbage    =   'slug';
        $data       =   $this->dataProvider()->without($garbage);

        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'model' =>  $data['model'],
        ]);
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with non string slug or not
     */
    public function it_must_reject_search_panel_store_requests_with_non_string_slug()
    {
        $garbage    =   'slug';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([null, false, true, '', []] as $invalid_title) {

            $data['slug']   =   $invalid_title;
            $response       =   $this->postJson($this->routeStore(), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with duplicated slug or not
     */
    public function it_must_reject_search_panel_store_requests_with_duplicated_slug()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->without('title',' slug', 'description')
        );
        $garbage        =   'slug';
        $data           =   $this->dataProvider()->without($garbage);
        $data['slug']   =   $existed_search_panel->slug;

        $response   =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'model' =>  $data['model'],
        ]);

    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can accept store request without description or not
     */
    public function it_must_accept_search_panel_store_requests_without_description()
    {
        $garbage        =   'description';
        $data           =   $this->dataProvider()->without($garbage);


        $response   =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->postJson($this->routeStore(), $data);

        $response->assertStatus(Response::HTTP_CREATED)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure([
                'data'  =>  ['id','title','slug','model','options','filters']
            ]);

        $this->assertDatabaseHas('search_panels',[
            'slug'  =>  $data['slug'],
            'model' =>  $data['model'],
        ]);
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with non string description or not
     */
    public function it_must_reject_search_panel_store_requests_with_non_string_description()
    {
        $garbage    =   'description';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([array(), random_int(0,mt_getrandmax())] as $invalid_description) {
            $data['description']    =   $invalid_description;
            $response               =   $this->postJson($this->routeStore(), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request without model or not
     */
    public function it_must_reject_search_panel_store_requests_without_model()
    {
        $garbage    =   'model';
        $data       =   $this->dataProvider()->without($garbage);

        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
        ]);
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with non string model or not
     */
    public function it_must_reject_search_panel_store_requests_with_non_string_model()
    {
        $garbage    =   'model';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([array(), random_int(0,mt_getrandmax())] as $invalid_description) {
            $data['model']  =   $invalid_description;
            $response       =   $this->postJson($this->routeStore(), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'slug'  =>  $data['slug'],
            ]);
        }
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request without filters or not
     */
    public function it_must_reject_search_panel_store_requests_without_filters()
    {
        $garbage    =   'filters';
        $data       =   $this->dataProvider()->without($garbage);
        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
        ]);
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with non json filters or not
     */
    public function it_must_reject_search_panel_store_requests_with_non_json_filters()
    {
        $garbage    =   'filters';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        // todo:if true sent then it will pass
        foreach ([null, false, "", []] as $invalid_title) {

            $data['filters']    =   $invalid_title;
            $response           =   $this->postJson($this->routeStore(), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request without options or not
     */
    public function it_must_reject_search_panel_store_requests_without_options()
    {
        $garbage    =   'options';
        $data       =   $this->dataProvider()->without($garbage);
        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
        ]);
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with non json options or not
     */
    public function it_must_reject_search_panel_store_requests_with_non_json_options()
    {
        $garbage    =   'options';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        // todo:if true sent then it will pass
        foreach ([null, false, "", []] as $invalid_title) {

            $data['filters']    =   $invalid_title;
            $response           =   $this->postJson($this->routeStore(), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }
    
    /**
     * @group search.panels.store
     * @test Let's check that it can reject store request with correct data
     */
    public function it_should_store_new_search_panel()
    {
        $data       =   $this->dataProvider()->getData();
        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->postJson($this->routeStore(), $data);
        $response->assertStatus(Response::HTTP_CREATED)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure([
                'data'  =>  ['id','title','slug','model','options','filters']
            ]);

        $this->assertDatabaseHas('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
            'model' =>  $data['model'],
        ]);
    }

    /**
     * @group search.panels.store
     * @test Let's check that it can handle exception during the store request
     */
    public function it_should_handle_exception_on_search_panel_store()
    {
        // todo:write test
    }

    /**
     * @group search.panels.show
     * @test Let's check that it can handle http not exception during the show request
     */
    public function it_must_return_not_found_if_search_panel_not_exists()
    {
        $response       =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->getJson($this->routeShow(random_int(1, mt_getrandmax())));

        $response->assertStatus(Response::HTTP_NOT_FOUND)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson([
                'errors'    =>  [
                    'not_found' =>  trans('http.not_found')
                ]
            ]);
    }

    /**
     * @group search.panels.show
     * @test Let's check that it can show SearchPanelResource on show request or not
     */
    public function it_should_return_search_panel_resource_when_search_panel_exists()
    {
        $sp =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $this->assertDatabaseHas('search_panels',[
            'title' =>  $sp->title,
            'slug'  =>  $sp->slug,
        ]);

        $response       =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->getJson($this->routeShow($sp->slug));


        $response->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure([
                'data'  =>  ['title', 'slug', 'description', 'model', 'options', 'filters']
            ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request without title or not
     */
    public function it_must_reject_search_panel_update_requests_without_title()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'title';
        $data       =   $this->dataProvider()->without($garbage);

        $response   =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->putJson($this->routeUpdate($existed_search_panel->slug), $data);

        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'slug'   =>  $data['slug'],
            'model'  =>  $data['model'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with non string title or not
     */
    public function it_must_reject_search_panel_update_requests_with_non_string_title()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );
        
        $garbage    =   'title';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([null, false, true, '', []] as $invalid_title) {

            $data['title']  =   $invalid_title;
            $response       =   $this->putJson($this->routeUpdate($existed_search_panel->slug), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'slug'   =>  $data['slug'],
                'model'  =>  $data['model'],
            ]);
        }
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request without slug or not
     */
    public function it_must_reject_search_panel_update_requests_without_slug()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'slug';
        $data       =   $this->dataProvider()->without($garbage);

        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->putJson($this->routeUpdate($existed_search_panel->slug), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'model' =>  $data['model'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with non string slug or not
     */
    public function it_must_reject_search_panel_update_requests_with_non_string_slug()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'slug';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([null, false, true, '', []] as $invalid_title) {

            $data['slug']   =   $invalid_title;
            $response       =   $this->putJson($this->routeUpdate($existed_search_panel->slug), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with duplicated slug or not
     */
    public function it_must_accept_search_panel_update_requests_with_same_slug()
    {
        $garbage        =   'slug';
        $data           =   $this->dataProvider()->without($garbage);
        $search_panels  =   factory(SearchPanel::class)->create(
            $this->dataProvider()->without('title',' slug', 'description')
        );
        $data['slug']   =   $search_panels->first()->slug;

        $response   =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->putJson($this->routeUpdate($search_panels->first()->slug), $data);

        $response->assertStatus(Response::HTTP_OK)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson([
                'data'  =>  ['row-effected'   =>  1]
            ]);

        $this->assertDatabaseHas('search_panels',[
            'title' =>  $data['title'],
            'model' =>  $data['model'],
        ]);

    }

    /**
     * @group search.panels.update
     * @test Let's check that it can accept store request without description or not
     */
    public function it_must_accept_search_panel_update_requests_without_description()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage        =   'description';
        $data           =   $this->dataProvider()->without($garbage);

        $response   =   $this->login(
            $this->userWithManageSearchPanelsPermission()
        )->putJson($this->routeUpdate($existed_search_panel->slug), $data);

        $response->assertStatus(Response::HTTP_OK)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson(['data'  =>  ['row-effected' => 1]]);

        $this->assertDatabaseHas('search_panels',[
            'slug'  =>  $data['slug'],
            'model' =>  $data['model'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with non string description or not
     */
    public function it_must_reject_search_panel_update_requests_with_non_string_description()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'description';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([array(), random_int(0,mt_getrandmax())] as $invalid_description) {
            $data['description']    =   $invalid_description;
            $response               =   $this->putJson($this->routeUpdate($existed_search_panel->slug), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request without model or not
     */
    public function it_must_reject_search_panel_update_requests_without_model()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'model';
        $data       =   $this->dataProvider()->without($garbage);

        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->putJson($this->routeUpdate($existed_search_panel->slug), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with non string model or not
     */
    public function it_must_reject_search_panel_update_requests_with_non_string_model()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'model';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        foreach ([array(), random_int(0,mt_getrandmax())] as $invalid_description) {
            $data['model']  =   $invalid_description;
            $response       =   $this->putJson($this->routeUpdate($existed_search_panel->slug), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'slug'  =>  $data['slug'],
            ]);
        }
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request without filters or not
     */
    public function it_must_reject_search_panel_update_requests_without_filters()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'filters';
        $data       =   $this->dataProvider()->without($garbage);
        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->putJson($this->routeUpdate($existed_search_panel->slug), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with non json filters or not
     */
    public function it_must_reject_search_panel_update_requests_with_non_json_filters()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'filters';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        // todo:if true sent then it will pass
        foreach ([null, false, "", []] as $invalid_title) {

            $data['filters']    =   $invalid_title;
            $response           =   $this->putJson($this->routeUpdate($existed_search_panel->slug), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request without options or not
     */
    public function it_must_reject_search_panel_update_requests_without_options()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );

        $garbage    =   'options';
        $data       =   $this->dataProvider()->without($garbage);
        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->putJson($this->routeUpdate($existed_search_panel->slug), $data);
        $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonValidationErrors($garbage);

        $this->assertDatabaseMissing('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with non json options or not
     */
    public function it_must_reject_search_panel_update_requests_with_non_json_options()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );
        $garbage    =   'options';
        $data       =   $this->dataProvider()->without($garbage);
        $this->login($this->userWithManageSearchPanelsPermission());
        // todo:if true sent then it will pass
        foreach ([null, false, "", []] as $invalid_title) {

            $data['filters']    =   $invalid_title;
            $response           =   $this->putJson($this->routeUpdate($existed_search_panel->slug), $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonValidationErrors($garbage);

            $this->assertDatabaseMissing('search_panels',[
                'title' =>  $data['title'],
                'model' =>  $data['model'],
            ]);
        }
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can reject store request with correct data
     */
    public function it_should_update_new_search_panel()
    {
        $existed_search_panel   =   factory(SearchPanel::class)->create(
            $this->dataProvider()->getData()
        );
        $data       =   $this->dataProvider()->getData();
        $response   =   $this->login($this->userWithManageSearchPanelsPermission())->putJson($this->routeUpdate($existed_search_panel->slug), $data);
        $response->assertStatus(Response::HTTP_OK)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson(['data'  =>  ['row-effected' => 1]]);

        $this->assertDatabaseHas('search_panels',[
            'title' =>  $data['title'],
            'slug'  =>  $data['slug'],
            'model' =>  $data['model'],
        ]);
    }

    /**
     * @group search.panels.update
     * @test Let's check that it can handle exception during the store request
     */
    public function it_should_handle_exception_on_search_panel_update()
    {
        // todo:write test
    }

    //todo:write test for delete, restore and destroy a search panel
}
