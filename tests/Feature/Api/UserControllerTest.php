<?php

namespace Test\Feature\Api;

use App\Events\User\UserStoreEvent;
use App\Http\Resources\PostsCollection;
use App\Http\Resources\UsersCollection;
use App\Models\User;
use Event;
use Hash;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Http\UploadedFile;
use Spatie\MediaLibrary\Models\Media;
use Spatie\Permission\Models\Role;
use Spatie\Permission\PermissionRegistrar;
use Symfony\Component\HttpFoundation\Response;
use Tests\TestCase;

class UserControllerTest extends TestCase
{
    use WithFaker;

    protected   $providedData   =   [];

    /**
     * @return mixed
     */
    public function userWithManageUsersPermission()
    {
        $this->artisan('db:seed', ['--class' => 'PermissionsTableSeeder']);
        $this->artisan('db:seed', ['--class' => 'RolesTableSeeder']);
        $user = factory(User::class)->create()->assignRole(Role::first());

        $this->assertTrue($user->hasRole('admin'));
        $this->assertTrue($user->hasPermissionTo('manage_users', 'api'));
        $this->assertCount(1, User::all());
        return $user;
    }

    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->app->make(PermissionRegistrar::class)->forgetCachedPermissions();
        $this->app->make(PermissionRegistrar::class)->registerPermissions();
    }

    protected function login(User $user = null)
    {
        return $this->clearConfigurationCache()->installPassport()->signInFromApi($user);
    }

    protected function routeIndex()
    {
        return route('api.users.index');
    }

    protected function routeStore()
    {
        return route('api.users.store');
    }

    protected function routeShow($user)
    {
        return route('api.users.show', ['user' => $user]);
    }

    protected function routeUpdate($user)
    {
        return route('api.users.update', ['user' => $user]);
    }

    protected function routeDelete($user)
    {
        return route('api.users.delete', ['user' => $user]);
    }

    protected function routeRestore($user)
    {
        return route('api.users.restore', ['user' => $user]);
    }

    protected function routeDestroy($user)
    {
        return route('api.users.destroy', ['user' => $user]);
    }

    protected function routeRoles($user)
    {
        return route('api.users.roles', ['user' => $user]);
    }

    protected function routeSyncRoles($user)
    {
        return route('api.users.roles.sync', ['user' => $user]);
    }

    protected function routePermissions($user)
    {
        return route('api.users.permissions', ['user' => $user]);
    }

    protected function dataProvider()
    {
        $password           =   str_random(random_int(6, 30));
        $this->providedData =   [
            'name'                  =>  $this->faker()->firstName,
            'email'                 =>  $this->faker()->email,
            'password'              =>  $password,
            'password_confirmation' =>  $password,
            'avatar'                =>  UploadedFile::fake()->image('avatar.jpg'),
        ];
        return $this;
    }

    protected function getData()
    {
        return $this->providedData;
    }

    protected function without(...$without)
    {
        if (count(func_get_args()) > 0) {
            foreach ($without as $key) {
                unset($this->providedData[$key]);
            }
        }

        return $this->providedData;
    }

    /**
     * @group users.index
     * @test Create 5 users and let check them exists in both response and db
     */
    public function it_must_unauthorized_user_should_not_have_access_to_user_list()
    {
        factory(User::class, 5)->create();
        $headers    =   [
            'Accept'            =>  enum('system.response.json'),
            'Content-Type'      =>  enum('system.response.json'),
            'X-Requested-With'  =>  enum('system.request.xhr'),
        ];

        $response   =   $this->getJson($this->routeIndex(), $headers);
        $response
            ->assertStatus(Response::HTTP_UNAUTHORIZED)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson(['message' =>  'Unauthenticated.']);
    }

    /**
     * @group users.index
     * @test Let's check that it can reject the users list request that comes from non permitted users or not
     */
    public function it_must_authorized_user_without_manage_users_permission_have_not_access_to_user_list()
    {
        factory(User::class, 5)->create();
        $response   =   $this->login()->withMiddleware()->getJson($this->routeIndex());
        $response
            ->assertStatus(Response::HTTP_UNAUTHORIZED)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJson(['message' =>  trans('http.unauthorized')]);
    }

    /**
     * @group users.index
     * @test Create 5 users and let check them exists in both response and db
     */
    public function it_must_authorized_user_with_manage_users_permission_have_access_to_user_list()
    {
        $this->artisan('db:seed', ['--class'    =>  'PermissionsTableSeeder']);
        $this->artisan('db:seed', ['--class'    =>  'RolesTableSeeder']);
        $this->artisan('db:seed', ['--class'    =>  'UsersTableSeeder']);
        // todo: how to unified role id in entire application
        $user   =   factory(User::class)->create()->assignRole(Role::first());

        $this->assertTrue($user->hasRole('admin'));
        $this->assertTrue($user->hasPermissionTo('manage_users', 'api'));

        $response   =   $this->login($user)->getJson($this->routeIndex());
        $response
            ->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonMissingExact(['errors'])
            ->assertJsonStructure([
                'data'  =>  ['*'    =>  [
                    'id','type','attributes','relations'
                ]]
            ]);
    }

    /**
     * @group users.index
     * @test Create 5 users and let check them exists in both response and db
     */
    public function it_must_always_return_user_resource()
    {
        $user       =   $this->userWithManageUsersPermission();
        $response   =   $this->login($user)->getJson($this->routeIndex());
        $response
            ->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonMissingExact(['errors'])
            ->assertJsonStructure([
                'data'  =>  ['*'    =>  [
                    'id','type','attributes','relations'
                ]]
            ]);
    }

    /**
     * @group users.store
     * @test let check it can make a user or not
     */
    public function it_must_reject_user_store_request_that_does_not_contain_the_name()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->without('name');
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure(['errors','message'])
            ->assertJsonValidationErrors('name');

        $this->assertDatabaseMissing('users', [
            'email' =>  $data['email']
        ]);
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_does_not_contain_the_email()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->without('email');
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure(['errors','message'])
            ->assertJsonValidationErrors('email');

        $this->assertDatabaseMissing('users', [
            'name'  =>  $data['name']
        ]);
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_does_not_contain_a_valid_email()
    {
        $user           =   $this->userWithManageUsersPermission();
        $data           =   $this->dataProvider()->without('email');
        $data['email']  =   str_random();
        $response       =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure(['errors','message'])
            ->assertJsonValidationErrors('email');

        $this->assertDatabaseMissing('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);
    }

    /**
    * @group users.store
    * @test
    */
    public function it_must_reject_user_store_request_that_does_not_contain_duplicated_email()
    {
        $user           =   $this->userWithManageUsersPermission();
        $data           =   $this->dataProvider()->without('email');
        $data['email']  =   $user->email;
        $response       =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure(['errors','message'])
            ->assertJsonValidationErrors('email');

        $this->assertDatabaseMissing('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_does_not_contain_the_password()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->without('password');
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure(['errors','message'])
            ->assertJsonValidationErrors('password');

        $this->assertDatabaseMissing('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_does_not_contain_string_password()
    {
        $this->login($this->userWithManageUsersPermission());
        $data   =   $this->dataProvider()->without('password');

        $invalidPasswords   =   [null, false, true, [], ''];
        foreach ($invalidPasswords as $password) {
            $data['password']   =   $password;
            $response           =   $this->postJson($this->routeStore(), $data);

            $response
                ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonStructure(['errors','message'])
                ->assertJsonValidationErrors('password');

            $this->assertDatabaseMissing('users', [
                'email' =>  $data['email'],
                'name'  =>  $data['name']
            ]);
        }
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_does_not_contain_a_least_six_char_password()
    {
        $this->login($this->userWithManageUsersPermission());
        $data   =   $this->dataProvider()->without('password');

        for ($i = 0; $i < 6; $i++) {
            $data['password']   =   str_random($i);
            $response           =   $this->postJson($this->routeStore(), $data);

            $response
                ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonStructure(['errors','message'])
                ->assertJsonValidationErrors('password');

            $this->assertDatabaseMissing('users', [
                'email' =>  $data['email'],
                'name'  =>  $data['name']
            ]);
        }
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_does_not_contain_confirmed_password()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->without('password_confirmation');
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonStructure(['errors','message'])
            ->assertJsonValidationErrors('password');

        $this->assertDatabaseMissing('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);
    }

    /**
     * @group users.store
     * @test
     */
    public function it_must_reject_user_store_request_that_contain_none_image_avatar()
    {
        $this->login($this->userWithManageUsersPermission());
        $data       =   $this->dataProvider()->without('avatar');

        $invalidImages  =   [
            null, false,true, str_random(), random_int(0, mt_getrandmax()),
            UploadedFile::fake()->create('excel.xls', 1024 * 10)
            ];

        foreach ($invalidImages as $image) {
            $data['avatar'] =   $image;
            $response       =   $this->postJson($this->routeStore(), $data);

            $response
                ->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY)
                ->assertHeader('Content-Type', enum('system.response.json'))
                ->assertJsonStructure(['errors','message'])
                ->assertJsonValidationErrors('avatar');

            $this->assertDatabaseMissing('users', [
                'email' =>  $data['email'],
                'name'  =>  $data['name']
            ]);
        }
    }




    /**
     * @group users.store
     * @test let check on bad request it reject request or not
     */
    public function the_user_password_that_is_stored_must_be_encrypted()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->getData();
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);
        $response
            ->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonMissing(['errors'])
            ->assertJsonStructure([
                'data'  =>  [
                    'id','type','attributes','relations'
                ]
            ]);

        $this->assertDatabaseHas('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);

        $createdUser    =   User::whereEmail($data['email'])->first();
        $isHash         =   Hash::check($data['password'], $createdUser->password);
        $this->assertTrue($isHash);
    }

    /**
     * @group users.show
     * @test let check that a created user can viewed or not
     */
    public function the_newly_saved_user_must_have_the_activation_token()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->getData();
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonMissing(['errors'])
            ->assertJsonStructure([
                'data'  =>  [
                    'id','type','attributes','relations'
                ]
            ]);

        $this->assertDatabaseHas('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);

        $createdUser    =   User::whereEmail($data['email'])->first();
        $this->assertNotNull($createdUser->activation_token);
    }

    /**
     * @group users.show
     * @test let check that a created user can viewed or not
     */
    public function the_newly_saved_user_if_sends_avatar_must_have_the_avatar()
    {
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->getData();
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonMissing(['errors'])
            ->assertJsonStructure([
                'data'  =>  [
                    'id','type','attributes','relations'
                ]
            ]);

        $this->assertDatabaseHas('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);

        $createdUser    =   User::whereEmail($data['email'])->first();
        $this->assertInstanceOf(Media::class, $createdUser->media->first());
    }

    /**
     * @group users.store
     * @test let check it can create a user and then update it or not
     */
    public function after_saving_a_new_user_send_an_activation_email()
    {
        Event::fake();
        $user       =   $this->userWithManageUsersPermission();
        $data       =   $this->dataProvider()->getData();
        $response   =   $this->login($user)->postJson($this->routeStore(), $data);

        $response
            ->assertSuccessful()
            ->assertHeader('Content-Type', enum('system.response.json'))
            ->assertJsonMissing(['errors'])
            ->assertJsonStructure([
                'data'  =>  [
                    'id','type','attributes','relations'
                ]
            ]);

        $this->assertDatabaseHas('users', [
            'email' =>  $data['email'],
            'name'  =>  $data['name']
        ]);

        Event::assertDispatched(UserStoreEvent::class, function ($event) use ($data) {
            return $event->user->name   === $data['name']
                && $event->user->email  === $data['email'];
        });
    }
}
